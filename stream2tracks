#! /usr/bin/ruby1.9.1

require 'optparse'
require 'ostruct'
require 'open-uri'
require 'digest/md5'
require 'nokogiri'
require 'taglib'
require 'fileutils'
include FileUtils

# A Stream is an abstraction of the input audio stream container that has:
# - a path, either a URI or filename
# - a key, uniquely identifying the stream
# - some metadata about the stream (Tags)
# - some entries
#
# Tags are metadata about a stream, its entries or a Track
#
# A Track is separate entry from a stream, containing:
# - some metadata about the track (Tags)
# - a URI
#
# A TrackFile is a file produced from a stream, containing:
# - some metadata about the track (Tags)
# - the filename
# - the format of the file

class Tags < Hash ; end

# TODO: perhaps delegate to tags via method_missing?
class Track < Struct.new :tags,:uri ; end

class TrackFile < Struct.new :tags,:filename,:format ; end


# An abstract class
class Stream
    attr_accessor :tags,:key

    def initialize path
	@path=path
	file=open(@path)
	@raw=file.read
	@tags=Tags.new
    end

    # To be implemented in the concrete subclass
    def entries ; end

    def key
	@key||=Digest::MD5.new.hexdigest(@raw).to_s
    end

    # To be implemented in the concrete subclass
    def parse ; end
end

class ASXStream < Stream
    def entries
	@xml||=Nokogiri::XML(@raw)
	@xml.css('ENTRY')
    end

    def parse
	title=entries.css('ASX>TITLE')[0]
	album=title.inner_text if title
	@tags[:album]=album
	count=0
	tracks=[]
	entries.each do |_|
	    tags=@tags.dup
	    count+=1
	    tags.merge!(
		:title=>_.css('TITLE').inner_text,
		:artist=>_.css('AUTHOR').inner_text,
		:track=>count
	    )
	    track=Track.new tags,_.css('REF')[0]['HREF']
	    tracks << track
	end
	tracks
    end
end

# A WatchedProcess is a process producing output which can be watched
# to indicate progress so far.
class WatchedProcess
    attr_accessor :pid,:out
    # TODO: support actually watching the process
    def initialize cmd
	@out,out_write=IO.pipe
	@pid=spawn cmd,:in=>:close,:out=>out_write,:err=>[:child,:out]
	yield self if block_given?
    end
end

class StreamTrackRipper
    Version=['0','0','1']

    def initialize stream,options
	@stream=stream
	@tracks=@stream.parse
	@options=options
	@curdir=Dir.pwd
	@workdir=File.join(ENV['HOME'],'.cache','stream2tracks',@stream.key)
	mkdir_p @workdir
	if block_given?
	    # TODO: support (re)processing selected tracks from any stage
	    trackfiles=get @tracks
	    trackfiles=convert trackfiles,@options.format
	    trackfiles=tag trackfiles
	    @trackfiles=rename trackfiles
	    yield
	end
	# TODO: handle log files, report on any failures
    end

    def get tracks
	trackfiles=[]
	processes=[]
	tracks.each do |track|
	    tags=track.tags
	    # TODO: support formats which may not be possible to determine
	    # from the file extension of the entry in the stream (using
	    # magic number from file itself).
	    format=File.extname(File.basename(track.uri)).sub(/^\./,'')
	    output_filename=File.join @workdir,'%02d.%s' % [tags[:track],format]
	    processes << (_=WatchedProcess.new('mimms -r "%s" "%s"' % [track.uri,output_filename]))
	    trackfiles << TrackFile.new(tags,output_filename,format)
	    Process.wait unless @options.multi
	end
	Process.waitall if @options.multi
	trackfiles
    end

    def convert trackfiles,format
	trackfiles.each do |trackfile|
	    tags=trackfile.tags
	    input_filename=trackfile.filename
	    output_filename=File.join @workdir,'%02d.%s' % [tags[:track],format]
	    cmd=case format
	    when 'ogg'
		'ffmpeg -i "%s" -acodec libvorbis "%s"' %
		    [input_filename,output_filename]
	    else # e.g. mp3, flac
		'ffmpeg -i "%s" "%s"' %
		    [input_filename,output_filename]
	    end
	    WatchedProcess.new cmd
	    Process.wait
	    rm input_filename
	    trackfile.filename=output_filename
	    trackfile.format=format
	end
	trackfiles
    end

    def tag trackfiles
	trackfiles.each do |trackfile|
	    tags=trackfile.tags
	    file=TagLib::File.new trackfile.filename
	    file.album  = tags[:album] if tags[:album]
	    file.title  = tags[:title]
	    file.artist = tags[:artist]
	    file.track  = tags[:track]
	    file.save
	end
	trackfiles
    end

    def rename trackfiles
	trackfiles.each do |trackfile|
	    tags=trackfile.tags
	    input_filename=trackfile.filename
	    output_filename='%02d-%s-%s.%s' %
		[tags[:track],tags[:album] ?
		    tags[:album] :
		    tags[:artist],tags[:title],
		trackfile.format]
	    # Strip characters that could cause problems for some target filesystems
	    output_filename.gsub!(/[:\/\\]/,' ')
	    # And reduce any blanks to underscores as a shell typing aid
	    output_filename.gsub!(/ +/,'_')

	    mv input_filename,output_filename
	    trackfile.filename=output_filename
	end
	trackfiles
    end
end

options=OpenStruct.new
options.format='ogg'
options.multi=false

OptionParser.new do |opts|
    opts.on('-f','--format FORMAT','Convert tracks to FORMAT (default %s).' % options.format) do |format|
	options.format=format
    end

    opts.on('-m','--multi','Download multiple tracks at once (EXPERIMENTAL).') do
	options.multi=true
    end

    opts.on_tail("-h", "--help", "Show this message") do
        puts opts
        exit
    end

    opts.on_tail("--version", "Show version") do
        puts StreamTrackRipper::Version.join('.')
        exit
    end
end.parse!

# FIXME: refactor into proper CLI/argument parser:
input_filename=ARGV.shift

StreamTrackRipper.new(ASXStream.new(input_filename),options){}
