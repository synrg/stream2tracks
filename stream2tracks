#! /usr/bin/env ruby

require 'optparse'
require 'ostruct'
require 'open-uri'
require 'nokogiri'
require 'tmpdir'
require 'taglib'
require 'fileutils'
include FileUtils

# A Stream is an abstraction of the input audio stream container that has:
# - a path, either a URI or filename
# - some metadata about the stream (Tags)
# - some entries
#
# Tags are metadata about a stream, its entries or a Track
#
# A Track is separate entry from a stream, containing:
# - some metadata about the track (Tags)
# - a URI
#
# A TrackFile is a file produced from a stream, containing:
# - some metadata about the track (Tags)
# - the filename
# - the format of the file

class Tags < Hash ; end

# TODO: perhaps delegate to tags via method_missing?
class Track < Struct.new :tags,:uri ; end

class TrackFile < Struct.new :tags,:filename,:format ; end


# An abstract class
class Stream
    attr_accessor :tags

    def initialize path
	@path=path
	file=open(@path)
	@raw=file.read
	@tags=Tags.new
    end

    # To be implemented in the concrete subclass
    def entries ; end

    # To be implemented in the concrete subclass
    def parse ; end
end

class ASXStream < Stream
    def entries
	@xml||=Nokogiri::XML(@raw)
	@xml.css('ENTRY')
    end

    def parse
	title=entries.css('ASX>TITLE')[0]
	album=title.inner_text if title
	@tags[:album]=album
	count=0
	tracks=[]
	entries.each do |_|
	    tags=@tags
	    count+=1
	    tags.merge!(
		:title=>_.css('TITLE').inner_text,
		:artist=>_.css('AUTHOR').inner_text,
		:track=>count
	    )
	    track=Track.new tags,_.css('REF')[0]['HREF']
	    tracks << track
	end
	tracks
    end
end

class StreamTrackRipper
    Version=['0','0','1']

    def initialize stream,options
	@stream=stream
	@tracks=@stream.parse
	@options=options
	@curdir=Dir.pwd
	@tmpdir=Dir.mktmpdir('s2t_')
	if block_given?
	    # TODO: support (re)processing selected tracks from any stage
	    trackfiles=get @tracks
	    trackfiles=convert trackfiles,@options.format
	    trackfiles=tag trackfiles
	    @trackfiles=rename trackfiles
	    yield
	end
	# TODO: handle log files, report on any failures
    end

    def get tracks
	@get_sh_filename=File.join @tmpdir,'get.sh'
	@get_log_filename=File.join @tmpdir,'get.log'
	trackfiles=[]
	File.open(@get_sh_filename,'w') do |sh|
	    sh.puts '#! /bin/sh'
	    sh.puts 'cd "%s"' % [@curdir]
	    tracks.each do |track|
		tags=track.tags
		# TODO: support formats which may not be possible to determine
		# from the file extension of the entry in the stream (using
		# magic number from file itself).
		format=File.extname(File.basename(track.uri)).sub(/^\./,'')
		output_filename=File.join @tmpdir,'%02d.%s' % [tags[:track],format]
		sh.puts 'mplayer -dumpstream -dumpfile "%s" "%s" %s' %
		    [output_filename,track.uri,@options.multi ? '&' : '']
		trackfiles << TrackFile.new(tags,output_filename,format)
	    end
	    # TODO: make it possible to start the processing pass as soon
	    # as each file download completes, rather than waiting for
	    # all of them to complete.
	    sh.puts 'wait' if @options.multi
	end
	system 'sh "%s" >"%s" 2>&1' % [@get_sh_filename,@get_log_filename]
	trackfiles
    end

    def convert trackfiles,format
	@convert_sh_filename=File.join @tmpdir,'convert.sh'
	@convert_log_filename=File.join @tmpdir,'convert.log'
	File.open(@convert_sh_filename,'w') do |sh|
	    sh.puts '#! /bin/sh'
	    sh.puts 'cd "%s"' % [@curdir]
	    trackfiles.each do |trackfile|
		tags=trackfile.tags
		input_filename=trackfile.filename
		output_filename=File.join @tmpdir,'%02d.%s' % [tags[:track],format]
		case format
		when 'ogg'
		    sh.puts 'ffmpeg -i "%s" -acodec libvorbis "%s"' %
			[input_filename,output_filename]
		else # e.g. mp3, flac
		    sh.puts 'ffmpeg -i "%s" "%s"' %
			[input_filename,output_filename]
		end
		sh.puts 'rm "%s"' % [input_filename]
		trackfile.filename=output_filename
		trackfile.format=format
	    end
	end
	system 'sh "%s" >"%s" 2>&1' % [@convert_sh_filename,@convert_log_filename]
	trackfiles
    end

    def tag trackfiles
	trackfiles.each do |trackfile|
	    tags=trackfile.tags
	    file=TagLib::File.new trackfile.filename
	    file.album  = tags[:album] if tags[:album]
	    file.title  = tags[:title]
	    file.artist = tags[:artist]
	    file.track  = tags[:track]
	    file.save
	end
	trackfiles
    end

    def rename trackfiles
	trackfiles.each do |trackfile|
	    tags=trackfile.tags
	    input_filename=trackfile.filename
	    output_filename='%02d-%s-%s.%s' %
		[tags[:track],tags[:album] ?
		    tags[:album] :
		    tags[:artist],tags[:title],
		trackfile.format]
	    # Strip characters that could cause problems for some target filesystems
	    output_filename.gsub!(/[:\/\\]/,' ')
	    # And reduce any blanks to underscores as a shell typing aid
	    output_filename.gsub!(/ +/,'_')

	    mv input_filename,output_filename
	    trackfile.filename=output_filename
	end
	trackfiles
    end
end

options=OpenStruct.new
options.format='ogg'
options.multi=false

OptionParser.new do |opts|
    opts.on('-f','--format FORMAT','Convert tracks to FORMAT (default %s).' % options.format) do |format|
	options.format=format
    end

    opts.on('-m','--multi','Download multiple tracks at once (EXPERIMENTAL).') do
	options.multi=true
    end

    opts.on_tail("-h", "--help", "Show this message") do
        puts opts
        exit
    end

    opts.on_tail("--version", "Show version") do
        puts StreamTrackRipper::Version.join('.')
        exit
    end
end.parse!

# FIXME: refactor into proper CLI/argument parser:
input_filename=ARGV.shift

StreamTrackRipper.new(ASXStream.new(input_filename),options){}
