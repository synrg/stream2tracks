#! /usr/bin/ruby1.9.1

require 'optparse'
require 'ostruct'
require 'open-uri'
require 'digest/md5'
require 'logger'
require 'nokogiri'
require 'taglib'
require 'progressbar'
require 'fileutils'
include FileUtils

# A Stream is an abstraction of the input audio stream container that has:
# - a path, either a URI or filename
# - a key, uniquely identifying the stream
# - some metadata about the stream (Tags)
# - some entries
#
# Tags are metadata about a stream, its entries or a Track
#
# A Track is separate entry from a stream, containing:
# - some metadata about the track (Tags)
# - a URI
#
# A TrackFile is a file produced from a stream, containing:
# - some metadata about the track (Tags)
# - the filename
# - the format of the file

class Tags < Hash ; end

# TODO: perhaps delegate to tags via method_missing?
class Track < Struct.new :tags,:uri ; end

class TrackFile < Struct.new :tags,:filename,:format ; end


# An abstract class
class Stream
    attr_accessor :tags,:key

    def initialize path
	@path=path
	file=open(@path)
	@raw=file.read
	@tags=Tags.new
    end

    # To be implemented in the concrete subclass
    def entries ; end

    def key
	@key||=Digest::MD5.new.hexdigest(@raw).to_s
    end

    # To be implemented in the concrete subclass
    def parse ; end
end

class ASXStream < Stream
    def entries
	xml.css('ENTRY')
    end

    def parse
	title=xml.css('ASX>TITLE')[0]
	album=title.inner_text if title
	@tags[:album]=album
	count=0
	tracks=[]
	entries.each do |_|
	    tags=@tags.dup
	    count+=1
	    tags.merge!(
		:title=>_.css('TITLE').inner_text,
		:artist=>_.css('AUTHOR').inner_text,
		:track=>count
	    )
	    track=Track.new tags,_.css('REF')[0]['HREF']
	    tracks << track
	end
	tracks
    end

    private

    def xml
	@xml||=Nokogiri::XML(@raw)
    end
end

# A WatchedProcess is a process producing output which can be watched
# to indicate progress so far.
class WatchedProcess
    MAX_READ_LEN=1024 # completely arbitrary
    class Status < Struct.new :eof,:valid,:current,:total ; end

    def initialize cmd
	@out,out_write=IO.pipe
	@pid=spawn cmd,:in=>:close,:out=>out_write,:err=>[:child,:out]
	out_write.close
	yield self if block_given?
    end

    def self.watch processes,options
	# TODO: instead of class attributes, the bar should belong to an instance
	# of a collection of processes. Likewise with status so that when the jobs
	# are done, the ripper can determine the final status of each track and
	# respond accordingly.
	@bar=nil
	update_bar=proc do |current,total|
	    @bar=ProgressBar.new('Downloading',total) if total!=@old_total or @bar.nil?
	    @old_total=total
	    @bar.set current
	end
	if Array===processes
	    all_done=false
	    until all_done do
		all_done=true
		current,@old_total,total=0,0,0
		processes.each do |_|
		    status=_.watch options
		    if status.current
			# The reported totals may not be accurate. Rather
			# than recompute the actual total when the track
			# finishes, just accumulate the reported total
			# to improve accuracy of the progress bar.
			current+=status.eof ? status.total : status.current
			total+=status.total
		    end
		    all_done=false unless status.eof
		end
		update_bar[current,total] if total>0
	    end
	else
	    eof=nil
	    @old_total=0
	    until eof
		status=processes.watch options
		eof=status.eof
		update_bar[status.current,status.total] if status.current && status.total>0
	    end
	end
	@bar.finish if @bar
    end

    def watch options
	progress,validate=options.progress,options.validate
	@buffer||=''
	output=@out.readpartial MAX_READ_LEN rescue EOFError
	@buffer << output if output
	$stderr.print output if options.debug and output
	if progress
	    current,total=progress[@buffer]
	end
	eof=@out.eof?
	valid=validate[@buffer] if validate
	Status.new eof,valid,current,total
    end
end

class StreamTrackRipper
    Version=['0','0','1']

    def initialize stream,options
	@stream=stream
	@options=options
	@log=Logger.new @options.log=='-' ? $stderr : @options.log if @options.log
	@tracks=@stream.parse
	@log.info 'Processing stream: %s' % @stream.key if @log
	@log.info 'Found %i tracks' % @tracks.count if @log
	album=@stream.tags[:album]
	@log.info 'Found stream title: %s' % album if @log and album
	@curdir=Dir.pwd
	@workdir=File.join(ENV['HOME'],'.cache','stream2tracks',@stream.key)
	mkdir_p @workdir
	if block_given?
	    # TODO: support (re)processing selected tracks from any stage
	    trackfiles=get @tracks
	    trackfiles=convert trackfiles,@options.format
	    trackfiles=tag trackfiles
	    @trackfiles=rename trackfiles
	    yield
	end
	# TODO: report on any failures
    end

    TO_BYTES={'GB'=>1000000000,'MB'=>1000000,'KB'=>1000}
    def get tracks
	trackfiles=[]
	processes=[]
	options=@options.dup
	unless options.quiet
	    options.progress=proc do |buffer|
		current,total=if buffer.scan(/(\d+\.\d+) (.B) \/ (\d+\.\d+) (.B)/m).last
		    cur,cur_unit,tot,tot_unit=$1,$2,$3,$4
		    [(cur.to_f*TO_BYTES[cur_unit.upcase]).to_i,
		     (tot.to_f*TO_BYTES[tot_unit.upcase]).to_i]
		end
		[current,total]
	    end
	    options.validate=proc do |buffer|
		buffer.include? 'Download complete!'
	    end
	end
	tracks.each do |track|
	    tags=track.tags
	    # TODO: support formats which may not be possible to determine
	    # from the file extension of the entry in the stream (using
	    # magic number from file itself).
	    format=File.extname(File.basename(track.uri)).sub(/^\./,'')
	    @log.info 'Track tags: %s' % tags.inspect if @log
	    output_filename=File.join @workdir,'%02d.%s' % [tags[:track],format]
	    if File.exists? output_filename
		@log.info 'Discarding old partial output: %s' % output_filename if @options.log
		rm output_filename
	    end
	    cmd='mimms "%s" "%s"' % [track.uri,output_filename]
	    @log.info 'Spawning: %s' % cmd if @log
	    processes << (_=WatchedProcess.new(cmd))
	    trackfiles << TrackFile.new(tags,output_filename,format)
	    WatchedProcess.watch _,options unless @options.multi
	end
	WatchedProcess.watch processes,options if @options.multi
	trackfiles
    end

    def convert trackfiles,format
	trackfiles.each do |trackfile|
	    tags=trackfile.tags
	    input_filename=trackfile.filename
	    output_filename=File.join @workdir,'%02d.%s' % [tags[:track],format]
	    cmd=case format
	    when 'ogg'
		'ffmpeg -i "%s" -acodec libvorbis "%s"' %
		    [input_filename,output_filename]
	    else # e.g. mp3, flac
		'ffmpeg -i "%s" "%s"' %
		    [input_filename,output_filename]
	    end
	    @log.info 'Spawning: %s' % cmd if @log
	    WatchedProcess.watch(WatchedProcess.new(cmd),@options)
	    rm input_filename
	    trackfile.filename=output_filename
	    trackfile.format=format
	end
	trackfiles
    end

    def tag trackfiles
	trackfiles.each do |trackfile|
	    @log.info 'Tagging: %s' % trackfile.filename if @log
	    tags=trackfile.tags
	    file=TagLib::File.new trackfile.filename
	    file.album  = tags[:album] if tags[:album]
	    file.title  = tags[:title]
	    file.artist = tags[:artist]
	    file.track  = tags[:track]
	    file.save
	end
	trackfiles
    end

    def rename trackfiles
	trackfiles.each do |trackfile|
	    tags=trackfile.tags
	    input_filename=trackfile.filename
	    output_filename='%02d-%s-%s.%s' %
		[tags[:track],tags[:album] ?
		    tags[:album] :
		    tags[:artist],tags[:title],
		trackfile.format]
	    # Strip characters that could cause problems for some target filesystems
	    output_filename.gsub!(/[:\/\\]/,' ')
	    # And reduce any blanks to underscores as a shell typing aid
	    output_filename.gsub!(/ +/,'_')

	    @log.info 'Renaming: %s to: %s' % [input_filename,output_filename] if @log
	    mv input_filename,output_filename
	    trackfile.filename=output_filename
	end
	trackfiles
    end
end

options=OpenStruct.new
options.format='ogg'
options.multi=false
options.debug=false
options.log=nil

OptionParser.new do |opts|
    opts.on('-d','--debug','Output debugging info.') do
	options.debug=true
    end

    opts.on('-f','--format FORMAT','Convert tracks to FORMAT (default %s).' % options.format) do |format|
	options.format=format
    end

    opts.on('-l','--log FILENAME','Log to FILENAME (or - for standard error).') do |filename|
	options.log=filename
    end

    opts.on('-m','--multi','Download multiple tracks at once (EXPERIMENTAL).') do
	options.multi=true
    end

    opts.on('-q','--quiet','Suppress output (progress bar).') do
	options.quiet=true
    end

    opts.on_tail('-h', '--help', 'Show this message.') do
        puts opts
        exit
    end

    opts.on_tail('--version', 'Show version.') do
        puts StreamTrackRipper::Version.join('.')
        exit
    end
end.parse!

# FIXME: refactor into proper CLI/argument parser:
input_filename=ARGV.shift

StreamTrackRipper.new(ASXStream.new(input_filename),options){}
